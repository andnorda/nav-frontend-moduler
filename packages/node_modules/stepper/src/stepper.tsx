import * as React from 'react';
import { useState, useEffect, useRef, forwardRef } from 'react';
import * as cn from 'classnames';

import StepperStep, { StepperStepProps } from './stepper-step';
import { omit } from 'nav-frontend-js-utils';

import 'stepper-style';

const cls = (compact) => cn('stepper', {
    'stepper--compact': compact
});

interface StepperProps {
    /**
     * Array av steg, se `stepper-steg.tsx`. Merk at steg også kan defineres som children av typen
     * <stepper.Steg />.
     */
    step?: StepperStepProps[];
    /**
     * Vise/skjule steg label
     */
    showLabel: boolean;
    /**
     * compact versjon som krever mye mindre plass
     */
    compact: boolean;
    /**
     * Optional aktivt steg override. Kan brukes hvis det f.eks. er flere stepperer på en side, hvor alle skal
     * oppdateres hvis den ene endrer seg.
     */
    activeStep?: number;
    /**
     * Valgfri callback som kjøres når state endrer seg etter click
     */
    onChange?: (index: number) => void;
    /**
     * Valgfri callback som kjøres før `onChange`. Kan avbryte kall til `onChange` hvis den returnerer `false`
     */
    onBeforeChange?: (index: number) => boolean;
    /**
     * Komponenten vil auto-justere seg selv avhengig av tilgjengelig konteiner-bredde, lytter på window `resize` event
     */
    autoReponsive: boolean;
}

const getDefaultActiveStepIndex = (children, step) => {
    let index;
    if (children) {
        React.Children.forEach(children, (child, i) => {
            if (React.isValidElement(child)) {
                const clone = React.cloneElement(child as React.ReactElement<any>);
                if (clone.props['active']) {
                    index = i;
                }
            }
        });
    } else {
        index = step!.findIndex((step) => !!step.active);
    }
    return (index !== -1) ? index : 0 ;
};

const getNumSteps = (children, step) => {
    if (children) {
        return React.Children.toArray(children).filter((child) => React.isValidElement(child)).length;
    }
    return step!.length;
};

const getDimensions = (children, step, list) => {
    const numSteps = getNumSteps(children, step);
    const remSize = parseFloat(String(getComputedStyle(document.documentElement).fontSize));
    const margin = remSize * 1.25;
    const marginTotal = (margin * numSteps) - margin;
    const showLabelWidth = ((remSize * 10) * numSteps) + marginTotal;
    const normalWidth = ((remSize * 2) * numSteps) + marginTotal;

    return {
        showLabelWidth,
        normalWidth,
        container: list.current!.getBoundingClientRect().width
    };
};

const canShowLabel = (children, step, list, showLabel) => {
    const dim = getDimensions(children, step, list);
    return dim.container >= dim.showLabelWidth && showLabel;
};

const canBeNormal = (children, step, list, compact) => {
    const dim = getDimensions(children, step, list);
    return dim.container >= dim.normalWidth && !compact;
};

const initialStep = (activeStep, children, step) => {
    let initialActiveStep;
    if (activeStep !== undefined) {
        initialActiveStep = activeStep;
    } else {
        initialActiveStep = getDefaultActiveStepIndex(children, step);
    }
    return initialActiveStep;
};

function stepperer(props:StepperProps, ref) {
    return <div></div>;
}

const Stepper = React.forwardRef<HTMLDivElement, StepperProps>((props, ref) => {

    const {
        step = [],
        showLabel = false,
        compact = false,
        activeStep,
        onChange,
        onBeforeChange,
        autoReponsive = false,
        children,
        ...others
    } = props;

    // ny state handling med bruk av hooks
    const [activeStepState, setactiveStepState] = useState(0);
    const [showLabelState, setshowLabelState] = useState(false);
    const [compactState, setcompactState] = useState(false);

    const list = useRef<HTMLOListElement>(null);

    const adjustSize = () => {
        if (!list.current) return;

        setshowLabelState(canShowLabel(children, step, list, showLabel));
        setcompactState(!canBeNormal(children, step, list, compact));
    };

    const useOnMount = () => {
        setactiveStepState(initialStep(activeStep, children, step));
        setcompactState(compact);
        setshowLabelState(showLabel);

        if (autoReponsive) {
            adjustSize();
        }
    };
    // Kjører etter komponent er byggd, erstatter "constructor" siden den kjører bare en gang
    useEffect(() => {
        useOnMount();
    },        []);

    // ComponentWillRecieveProps alternativ, men kjører bare for spesifikke props
    useEffect(() => {
        if (autoReponsive) {
            const label = (canShowLabel(children, step, list, showLabel)) ? showLabel : false;
            setshowLabelState(label);
            setcompactState(compact || !canBeNormal(children, step, list, compact));
        } else {
            setshowLabelState(showLabel);
            setcompactState(compact);
        }
    },        [autoReponsive, compact, showLabel]);

    useEffect(() => {
        if (activeStep !== undefined && activeStep !== activeStepState) {
            setactiveStepState(activeStep);
        }
    },        [activeStep]);

    // Returnerer en removeEventListener funk som kjøres hver gang denne effekten blir kjørt igjen, Sikrer da at
    // eventListener blir fjernet riktig når den skal. Kjøres også på component Unmount
    useEffect(() => {
        if (!autoReponsive) return;
        window.addEventListener('resize', adjustSize);
        return () => window.removeEventListener('resize', adjustSize);
    },        [autoReponsive]);

    const handleClick = (e, index) => {
        e.preventDefault();
        if (!onBeforeChange || onBeforeChange(index)) {
            setactiveStepState(index);
            // tslint:disable-next-line:no-unused-expression
            if (typeof onChange === 'function') onChange(index)!;
        }
    };

    const renderStep = () => {
        const onClick = (i) => (typeof onChange === 'function') ? (e) => handleClick(e, i) : undefined;

        if (children) {
            return React.Children.map(children, (child, i) => {
                if (React.isValidElement(child)) {
                    return React.cloneElement(child as React.ReactElement<any>, {
                        index: child.props['index'] || i,
                        active: i === activeStepState,
                        done: child.props['done'] || i < activeStepState,
                        onClick: (!child.props['disabled']) ? onClick(i) : undefined,
                        showLabel: showLabelState
                    });
                }
                return child;
            });
        }

        return step!.map((step, i) => {

            const stepDomProps = omit(
                step,
                'label',
                'active',
                'done',
                'showLabel',
                'index',
                'onClick'
            );

            const completed = step.done || i < activeStepState;
            const active = i === activeStepState;

            return (
                <StepperStep
                    index={i}
                    label={step.label}
                    showLabel={showLabelState}
                    key={`${step.label.split(' ').join('')}`}
                    active={active}
                    done={completed}
                    onClick={(!step.disabled) ? onClick(i) : undefined}
                    {...stepDomProps}
                />
            );
        });
    };

    return (
        <div ref={ref} className={cls(compactState)} {...others}>
            <ol
                className="stepper__list"
                ref={list}
            >
                {renderStep()}
            </ol>
        </div>
    );
});

// export default forwardRef(stepper);
export default Stepper;
