import * as React from 'react';
import { useState, useEffect, useRef } from 'react';
import * as cn from 'classnames';

import StegindikatorSteg, { StegindikatorStegProps } from './Stegindikator-steg';
import { omit } from 'nav-frontend-js-utils';

import 'nav-frontend-stegindikator-style';

const cls = (kompakt) => cn('stegindikator', {
    'stegindikator--kompakt': kompakt
});

interface StepperProps {
    /**
     * Array av steg, se `stegindikator-steg.tsx`. Merk at steg også kan defineres som children av typen
     * <Stegindikator.Steg />.
     */
    steg?: StegindikatorStegProps[];
    /**
     * Vise/skjule steg label
     */
    visLabel: boolean;
    /**
     * Kompakt versjon som krever mye mindre plass
     */
    kompakt: boolean;
    /**
     * Optional aktivt steg override. Kan brukes hvis det f.eks. er flere stegindikatorer på en side, hvor alle skal
     * oppdateres hvis den ene endrer seg.
     */
    aktivtSteg?: number;
    /**
     * Valgfri callback som kjøres når state endrer seg etter click
     */
    onChange?: (index: number) => void;
    /**
     * Valgfri callback som kjøres før `onChange`. Kan avbryte kall til `onChange` hvis den returnerer `false`
     */
    onBeforeChange?: (index: number) => boolean;
    /**
     * Komponenten vil auto-justere seg selv avhengig av tilgjengelig konteiner-bredde, lytter på window `resize` event
     */
    autoResponsiv: boolean;
}

const Stepper = React.forwardRef<HTMLDivElement, StepperProps>((props, ref) => {

    const {
        steg = [],
        visLabel = false,
        kompakt = false,
        aktivtSteg,
        onChange,
        onBeforeChange,
        autoResponsiv = false,
        children,
        ...others
    } = props;

    // ny state handling med bruk av hooks
    const [activeStep, setActiveStep] = useState(0);
    const [showLabel, setShowLabel] = useState(false);
    const [compact, setCompact] = useState(false);

    const list = useRef<HTMLOListElement>(null);

    const getDefaultActiveStegIndex = () => {
        let index;
        if (children) {
            React.Children.forEach(children, (child, i) => {
                if (React.isValidElement(child)) {
                    const clone = React.cloneElement(child as React.ReactElement<any>);
                    if (clone.props['aktiv']) {
                        index = i;
                    }
                }
            });
        } else {
            index = steg!.findIndex((steg) => !!steg.aktiv);
        }
        return (index !== -1) ? index : 0 ;
    };

    const getNumSteg = () => {
        if (children) {
            return React.Children.toArray(children).filter((child) => React.isValidElement(child)).length;
        }
        return steg!.length;
    };

    const getDimensions = () => {
        const numSteg = getNumSteg();
        const remSize = parseFloat(String(getComputedStyle(document.documentElement).fontSize));
        const margin = remSize * 1.25;
        const marginTotal = (margin * numSteg) - margin;
        const visLabelWidth = ((remSize * 10) * numSteg) + marginTotal;
        const normalWidth = ((remSize * 2) * numSteg) + marginTotal;

        return {
            visLabelWidth,
            normalWidth,
            container: list.current!.getBoundingClientRect().width
        };
    };

    const adjustSize = () => {
        if (!list.current) return;

        setShowLabel(canShowLabel());
        setCompact(!canBeNormal());
    };

    const canShowLabel = () => {
        const dim = getDimensions();
        return dim.container >= dim.visLabelWidth && visLabel;
    };

    const canBeNormal = () => {
        const dim = getDimensions();
        return dim.container >= dim.normalWidth && !kompakt;
    };

    const initialSteg = () => {
        let initialAktivtSteg;
        if (aktivtSteg !== undefined) {
            initialAktivtSteg = aktivtSteg;
        } else {
            initialAktivtSteg = getDefaultActiveStegIndex();
        }
        return initialAktivtSteg;
    };

    // Kjører etter komponent er byggd, erstatter "constructor" siden den kjører bare en gang
    useEffect(() => {
        setActiveStep(initialSteg());
        setCompact(kompakt);
        setShowLabel(visLabel);

        if (autoResponsiv) {
            adjustSize();
        }
    },        []);

    // ComponentWillRecieveProps alternativ, men kjører bare for spesifikke props
    useEffect(() => {
        if (autoResponsiv) {
            const label = (canShowLabel()) ? visLabel : false;
            setShowLabel(label);
            setCompact(kompakt || !canBeNormal());
        } else {
            setShowLabel(visLabel);
            setCompact(kompakt);
        }
    },        [autoResponsiv, kompakt, visLabel]);

    useEffect(() => {
        if (aktivtSteg !== undefined && aktivtSteg !== activeStep) {
            setActiveStep(aktivtSteg);
        }
    },        [aktivtSteg]);

    // Returnerer en removeEventListener funk som kjøres hver gang denne effekten blir kjørt igjen, Sikrer da at
    // eventListener blir fjernet riktig når den skal. Kjøres også på component Unmount
    useEffect(() => {
        if (!autoResponsiv) return;
        window.addEventListener('resize', adjustSize);
        return () => window.removeEventListener('resize', adjustSize);
    },        [autoResponsiv]);

    const handleClick = (e, index) => {
        e.preventDefault();
        if (!onBeforeChange || onBeforeChange(index)) {
            setActiveStep(index);
            // tslint:disable-next-line:no-unused-expression
            if (typeof onChange === 'function') onChange(index)!;
        }
    };

    const renderSteg = () => {
        const onClick = (i) => (typeof onChange === 'function') ? (e) => handleClick(e, i) : undefined;

        if (children) {
            return React.Children.map(children, (child, i) => {
                if (React.isValidElement(child)) {
                    return React.cloneElement(child as React.ReactElement<any>, {
                        index: child.props['index'] || i,
                        aktiv: i === activeStep,
                        ferdig: child.props['ferdig'] || i < activeStep,
                        onClick: (!child.props['disabled']) ? onClick(i) : undefined,
                        visLabel: showLabel
                    });
                }
                return child;
            });
        }

        return steg!.map((steg, i) => {

            const stegDomProps = omit(
                steg,
                'label',
                'aktiv',
                'ferdig',
                'visLabel',
                'index',
                'onClick'
            );

            const ferdig = steg.ferdig || i < activeStep;
            const aktiv = i === activeStep;

            return (
                <StegindikatorSteg
                    index={i}
                    label={steg.label}
                    visLabel={showLabel}
                    key={`${steg.label.split(' ').join('')}`}
                    aktiv={aktiv}
                    ferdig={ferdig}
                    onClick={(!steg.disabled) ? onClick(i) : undefined}
                    {...stegDomProps}
                />
            );
        });
    };

    return (
        <div ref={ref} className={cls(compact)} {...others}>
            <ol
                className="stegindikator__liste"
                ref={list}
            >
                {renderSteg()}
            </ol>
        </div>
    );
});

export default Stepper;
